"use strict";
/*
* @adonisjs/cli
*
* (c) Harminder Virk <virk@adonisjs.com>
*
* For the full copyright and license information, please view the LICENSE
* file that was distributed with this source code.
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const resolve_from_1 = __importDefault(require("resolve-from"));
const fs_1 = require("fs");
const utils_1 = require("@poppinss/utils");
const path_1 = require("path");
const validateCommand_1 = require("../utils/validateCommand");
const CommandValidationException_1 = require("../Exceptions/CommandValidationException");
const MissingManifestFileException_1 = require("../Exceptions/MissingManifestFileException");
/**
 * Manifest class drastically improves the commands performance, by generating
 * a manifest file for all the commands and lazy load only the executed
 * command.
 */
class Manifest {
    constructor(basePath) {
        this.basePath = basePath;
    }
    /**
     * Write file to the disk
     */
    writeManifest(manifest) {
        return new Promise((resolve, reject) => {
            fs_1.writeFile(path_1.join(this.basePath, 'ace-manifest.json'), JSON.stringify(manifest), (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    /**
     * Loads a single command from the manifest commands list.
     */
    loadCommand(commandPath) {
        const absPath = resolve_from_1.default(this.basePath, commandPath);
        const command = utils_1.esmRequire(absPath);
        if (!command.name) {
            throw CommandValidationException_1.CommandValidationException.invalidManifestExport(commandPath);
        }
        command.$boot();
        return {
            command,
            commandPath,
        };
    }
    /**
     * Look up commands from a given path. The modules can also return an array
     * of sub-paths from where to load additional commands.
     */
    lookupCommands(commandPath) {
        /**
         * Absolute paths are not allowed when looking up commands to be saved
         * inside the manifest file. This is required, since one can accidentally
         * generate absolute paths on their local machine and then trying to
         * execute commands on a server
         */
        if (path_1.isAbsolute(commandPath)) {
            throw new Error('Absolute path to commands are not allowed, since manifest file needs to be portable');
        }
        const absPath = resolve_from_1.default(this.basePath, commandPath);
        const commandOrCommandPaths = utils_1.esmRequire(absPath);
        /**
         * The command exports an array of subpaths. Only one level
         * of subpaths are allowed.
         */
        if (Array.isArray(commandOrCommandPaths)) {
            return commandOrCommandPaths.map((commandOrCommandPath) => {
                return this.loadCommand(commandOrCommandPath);
            });
        }
        return [this.loadCommand(commandPath)];
    }
    /**
     * Generates the manifest file for the given command paths
     */
    async generate(commandPaths) {
        const manifest = commandPaths.reduce((result, path) => {
            const commands = this.lookupCommands(path);
            commands.forEach(({ command, commandPath }) => {
                validateCommand_1.validateCommand(command);
                result[command.commandName] = {
                    settings: command.settings || {},
                    commandPath: commandPath.replace(new RegExp(`${path_1.extname(commandPath)}$`), ''),
                    commandName: command.commandName,
                    description: command.description,
                    args: command.args,
                    flags: command.flags,
                };
            });
            return result;
        }, {});
        await this.writeManifest(manifest);
    }
    /**
     * Load the manifest file from the disk. An exception is raised
     * when `manifest` file is missing. So the consumer must ensure
     * that file exists before calling this method.
     */
    load() {
        return new Promise((resolve, reject) => {
            fs_1.readFile(path_1.join(this.basePath, 'ace-manifest.json'), 'utf-8', (error, contents) => {
                if (error) {
                    if (error.code === 'ENOENT') {
                        reject(MissingManifestFileException_1.MissingManifestFileException.invoke());
                    }
                    else {
                        reject(error);
                    }
                }
                else {
                    resolve(JSON.parse(contents));
                }
            });
        });
    }
}
exports.Manifest = Manifest;
