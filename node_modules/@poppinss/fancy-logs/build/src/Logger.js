"use strict";
/*
* @poppinss/fancy-logs
*
* (c) Harminder Virk <virk@adonisjs.com>
*
* For the full copyright and license information, please view the LICENSE
* file that was distributed with this source code.
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const figures_1 = __importDefault(require("figures"));
const util_1 = require("util");
const string_width_1 = __importDefault(require("string-width"));
const serialize_error_1 = require("serialize-error");
const colors_1 = require("@poppinss/colors");
/**
 * Logger exposes the API to print fancy logs to the console.
 */
class Logger {
    constructor(baseOptions) {
        this.baseOptions = baseOptions;
        /**
         * List of actions that can be logged using the logger
         */
        this.actions = {
            success: {
                color: 'green',
                badge: figures_1.default.tick,
                logLevel: 'info',
            },
            fatal: {
                color: 'red',
                badge: figures_1.default.cross,
                logLevel: 'error',
            },
            error: {
                color: 'red',
                badge: figures_1.default.cross,
                logLevel: 'error',
            },
            info: {
                color: 'blue',
                badge: figures_1.default.info,
                logLevel: 'info',
            },
            complete: {
                color: 'cyan',
                badge: figures_1.default.checkboxOn,
                logLevel: 'info',
            },
            pending: {
                color: 'magenta',
                badge: figures_1.default.checkboxOff,
                logLevel: 'info',
            },
            create: {
                color: 'green',
                badge: figures_1.default.tick,
                logLevel: 'info',
            },
            update: {
                color: 'yellow',
                badge: figures_1.default.tick,
                logLevel: 'info',
            },
            delete: {
                color: 'blue',
                badge: figures_1.default.tick,
                logLevel: 'info',
            },
            watch: {
                color: 'yellow',
                badge: figures_1.default.ellipsis,
                logLevel: 'info',
            },
            start: {
                color: 'green',
                badge: figures_1.default.play,
                logLevel: 'info',
            },
            stop: {
                color: 'magenta',
                badge: figures_1.default.squareSmallFilled,
                logLevel: 'info',
            },
            compile: {
                color: 'yellow',
                badge: figures_1.default.pointer,
                logLevel: 'info',
            },
            skip: {
                color: 'magenta',
                badge: figures_1.default.bullet,
                logLevel: 'info',
            },
            warn: {
                color: 'yellow',
                badge: figures_1.default.warning,
                logLevel: 'info',
            },
        };
        /**
         * Array of logs collected when logger was paused. Helps in
         * collecting logs and then filtering them during resume.
         */
        this.deferredLogs = [];
        /**
         * Is logger paused from printing logs
         */
        this.isPaused = false;
        /**
         * An array of logs collected only when `fake` is set
         * to true
         */
        this.logs = [];
        this.configure();
        this.computeBiggestLabel();
    }
    /**
     * Configures the logger
     */
    configure() {
        this.baseOptions = Object.assign({
            color: true,
            icon: true,
            underline: true,
            fake: false,
        }, this.baseOptions);
        this.colors = this.baseOptions.fake ? new colors_1.FakeColors() : new colors_1.Colors();
    }
    /**
     * Computes the length of the biggest label including it's icon. Required
     * to justify content
     */
    computeBiggestLabel() {
        this.biggestLabel = Math.max(...Object.keys(this.actions).map((name) => {
            const action = this.actions[name];
            const badge = this.colors[action.color](action.badge);
            const label = this.colors[action.color]().underline(name);
            return string_width_1.default(`${badge}  ${label}`);
        }));
    }
    /**
     * Returns the base message node
     */
    normalizeMessage(message) {
        /**
         * Message itself is an error object, so we add icon, color and underline
         * to props to it
         */
        if (message['stack']) {
            const serializedMessage = serialize_error_1.serializeError(message);
            serializedMessage['icon'] = this.baseOptions.icon;
            serializedMessage['color'] = this.baseOptions.color;
            serializedMessage['underline'] = this.baseOptions.underline;
            return serializedMessage;
        }
        /**
         * Message is a string, so we use the defaults + the message text
         */
        if (typeof (message) === 'string') {
            return Object.assign({}, this.baseOptions, { message });
        }
        /**
         * Message is an object, but it's message is an error object. In that
         * case, we merge the props of message with the defaults and then
         * copy them over the message.message error object. CONFUSED?
         */
        if (message.message['stack']) {
            const serializedMessage = serialize_error_1.serializeError(message.message);
            const options = Object.assign({}, this.baseOptions, message);
            serializedMessage['icon'] = options.icon;
            serializedMessage['color'] = options.color;
            serializedMessage['underline'] = options.underline;
            return serializedMessage;
        }
        return Object.assign({}, this.baseOptions, message);
    }
    /**
     * Returns whitespace for a given length
     */
    getWhitespace(length) {
        return this.baseOptions.fake ? ' ' : new Array(length + 1).join(' ');
    }
    /**
     * Returns the icon for a given action type
     */
    getIcon(name, messageNode) {
        const action = this.actions[name];
        if (this.baseOptions.fake) {
            return '';
        }
        if (!messageNode.icon) {
            return this.getWhitespace(3);
        }
        if (!messageNode.color) {
            return `${action.badge}${this.getWhitespace(2)}`;
        }
        return `${this.colors[action.color](action.badge)}${this.getWhitespace(2)}`;
    }
    /**
     * Returns the label for a given action type
     */
    getLabel(name, messageNode) {
        const action = this.actions[name];
        if (messageNode.color && messageNode.underline) {
            return this.colors.underline()[action.color](name);
        }
        if (messageNode.color) {
            return this.colors[action.color](name);
        }
        return name;
    }
    /**
     * Returns the prefix for the message
     */
    getPrefix(messageNode) {
        if (messageNode.prefix) {
            return `${this.colors.dim(messageNode.prefix)}${this.getWhitespace(1)}`;
        }
        return '';
    }
    /**
     * Returns the suffix for the message
     */
    getSuffix(messageNode) {
        if (messageNode.suffix) {
            return `${this.getWhitespace(1)}${this.colors.dim().yellow(messageNode.suffix)}`;
        }
        return '';
    }
    /**
     * Formats error message
     */
    formatStack(name, message) {
        if (name !== 'fatal' || !message['stack']) {
            return message.message;
        }
        const stack = message['stack'].split('\n');
        return `${stack.shift()}\n${stack.map((line) => {
            return `${this.colors.dim(line)}`;
        }).join('\n')}`;
    }
    /**
     * Invokes `console[logMethod]`, gives opportunity to overwrite the
     * method during extend
     */
    $log(logMethod, message, args) {
        console[logMethod](message, ...args);
    }
    /**
     * Prints message node to the console
     */
    $printMessage(message) {
        const prefix = this.getPrefix(message);
        const icon = this.getIcon(message.action, message);
        const label = this.getLabel(message.action, message);
        const formattedMessage = this.formatStack(message.action, message);
        const suffix = this.getSuffix(message);
        if (this.baseOptions.fake) {
            const log = util_1.format(`${prefix}${icon}${label} ${formattedMessage}${suffix}`, ...message.args);
            this.logs.push(log);
            return log;
        }
        const method = this.actions[message.action].logLevel === 'error' ? 'error' : 'log';
        /**
         * Justification whitespace is required justify the text after the
         * icon and label
         */
        const justifyWhitespace = this.getWhitespace((this.biggestLabel - string_width_1.default(`${icon}${label}`)) + 2);
        this.$log(method, `${prefix}${icon}${label}${justifyWhitespace}${formattedMessage}${suffix}`, message.args);
    }
    /**
     * Log message for a given action
     */
    log(name, messageNode, ...args) {
        const normalizedMessage = this.normalizeMessage(messageNode);
        const message = Object.assign({ action: name, args }, normalizedMessage);
        if (this.isPaused) {
            this.deferredLogs.push(message);
            return;
        }
        return this.$printMessage(message);
    }
    /**
     * Print success message
     */
    success(message, ...args) {
        return this.log('success', message, ...args);
    }
    /**
     * Print error message
     */
    error(message, ...args) {
        return this.log('error', message, ...args);
    }
    /**
     * Print fatal message
     */
    fatal(message, ...args) {
        return this.log('fatal', message, ...args);
    }
    /**
     * Print info message
     */
    info(message, ...args) {
        return this.log('info', message, ...args);
    }
    /**
     * Print complete message
     */
    complete(message, ...args) {
        return this.log('complete', message, ...args);
    }
    /**
     * Print pending message
     */
    pending(message, ...args) {
        return this.log('pending', message, ...args);
    }
    /**
     * Print create message
     */
    create(message, ...args) {
        return this.log('create', message, ...args);
    }
    /**
     * Print update message
     */
    update(message, ...args) {
        return this.log('update', message, ...args);
    }
    /**
     * Print delete message
     */
    delete(message, ...args) {
        return this.log('delete', message, ...args);
    }
    /**
     * Print watch message
     */
    watch(message, ...args) {
        return this.log('watch', message, ...args);
    }
    /**
     * Print start message
     */
    start(message, ...args) {
        return this.log('start', message, ...args);
    }
    /**
     * Print stop message
     */
    stop(message, ...args) {
        return this.log('stop', message, ...args);
    }
    /**
     * Print compile message
     */
    compile(message, ...args) {
        return this.log('compile', message, ...args);
    }
    /**
     * Print skip message
     */
    skip(message, ...args) {
        return this.log('skip', message, ...args);
    }
    /**
     * Print skip message
     */
    warn(message, ...args) {
        return this.log('warn', message, ...args);
    }
    /**
     * Pause the logger and collect logs in memory
     */
    pauseLogger() {
        this.isPaused = true;
    }
    /**
     * Resume logger and pass a function to decide whether or not
     * to print the log
     */
    resumeLogger(filterFn) {
        this.isPaused = false;
        this.deferredLogs.forEach((log) => {
            if (typeof (filterFn) !== 'function' || filterFn(log)) {
                this.$printMessage(log);
            }
        });
        this.deferredLogs = [];
    }
}
exports.Logger = Logger;
